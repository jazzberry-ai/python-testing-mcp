# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\nclient<llm> GeminiFlash {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-1.5-flash\"\n    api_key env.GEMINI_API_KEY\n  }\n}\n\nclient<llm> GeminiPro {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-1.5-pro\"\n    api_key env.GEMINI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT4o {\n  provider openai\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT4oMini {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet {\n  provider anthropic\n  options {\n    model \"claude-3-5-sonnet-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-haiku-20240307\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [GeminiFlash, CustomGPT4oMini]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> TestingFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [GeminiFlash, CustomGPT4oMini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  // Strategy is optional\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  // Strategy is optional\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.202.1\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "testing.baml": "// BAML schemas for software testing tools\n\n// Fuzzing test input data model\nclass FuzzTestInput {\n  args (string | int | float | bool | null)[]\n  kwargs map<string, (string | int | float | bool | null)>\n  description string\n  expected_behavior \"normal\" | \"error\" | \"edge_case\"\n}\n\n// Crash analysis result\nclass CrashAnalysis {\n  root_cause string\n  severity \"low\" | \"medium\" | \"high\" | \"critical\"\n  suggested_fix string\n  additional_test_cases string[]\n}\n\n// Unit test case structure\nclass UnitTestCase {\n  name string\n  description string\n  test_code string\n  imports string[]\n}\n\n// Coverage improvement suggestion\nclass CoverageImprovement {\n  file_path string\n  function_name string\n  current_coverage_percentage float\n  suggestion_type \"missing_tests\" | \"edge_cases\" | \"error_handling\"\n  priority \"low\" | \"medium\" | \"high\"\n  suggested_tests string[]\n  code_examples string[]\n}\n\n// Mutation testing schemas\n\n// Mutation operator definition\nclass MutationOperator {\n  name string\n  description string\n  category \"arithmetic\" | \"comparison\" | \"logical\" | \"boolean\" | \"constant\" | \"statement\"\n  original_pattern string\n  mutated_pattern string\n  risk_level \"low\" | \"medium\" | \"high\"\n}\n\n// Individual mutant information\nclass Mutant {\n  id string\n  operator_name string\n  original_code string\n  mutated_code string\n  line_number int\n  column_number int\n  function_name string\n  description string\n}\n\n// Result of testing a single mutant\nclass MutationResult {\n  mutant_id string\n  status \"killed\" | \"survived\" | \"timeout\" | \"error\"\n  execution_time_ms int\n  test_output string\n  failing_tests string[]\n  error_message string\n}\n\n// Mutation strategy recommendation\nclass MutationStrategy {\n  target_functions string[]\n  recommended_operators MutationOperator[]\n  priority_areas string[]\n  expected_mutant_count int\n  rationale string\n}\n\n// Comprehensive mutation testing report\nclass MutationReport {\n  total_mutants int\n  killed_mutants int\n  survived_mutants int\n  timeout_mutants int\n  error_mutants int\n  mutation_score float\n  function_scores map<string, float>\n  weak_areas string[]\n  improvement_suggestions string[]\n}\n\n// Generate fuzzing test inputs for a Python function\nfunction GenerateFuzzingInputs(\n  function_signature: string,\n  function_code: string,\n  num_inputs: int\n) -> FuzzTestInput[] {\n  client TestingFallback\n  prompt #\"\n    Analyze this Python function and generate {{ num_inputs }} diverse fuzzing test inputs.\n    Focus on edge cases, boundary conditions, and potential error conditions.\n\n    Function signature: {{ function_signature }}\n    Function code:\n    ```python\n    {{ function_code }}\n    ```\n\n    Generate test inputs that cover:\n    1. Normal valid inputs\n    2. Edge cases (empty, null, boundary values)\n    3. Invalid inputs that might cause errors\n    4. Large inputs that might cause performance issues\n    5. Unusual data types or formats\n\n    For special values use:\n    - For infinity: use string \"infinity\" not float('inf')\n    - For None/null: use null\n    - For very large numbers: use regular integers like 999999999\n    - Use only standard JSON types: string, number, boolean, null, array\n\n    Generate realistic test cases with appropriate descriptions and expected behavior.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Analyze a crash and provide insights\nfunction AnalyzeCrash(\n  function_code: string,\n  error_info: string,\n  test_input: string\n) -> CrashAnalysis {\n  client TestingFallback\n  prompt #\"\n    Analyze this Python function crash and provide insights:\n\n    Function code:\n    ```python\n    {{ function_code }}\n    ```\n\n    Error:\n    {{ error_info }}\n\n    Test input that caused the crash:\n    {{ test_input }}\n\n    Provide a comprehensive analysis including root cause, severity assessment, suggested fix, and additional test cases to prevent similar issues.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Generate unit test cases for a function\nfunction GenerateUnitTestCases(\n  function_signature: string,\n  function_code: string,\n  framework: string,\n  docstring: string\n) -> UnitTestCase[] {\n  client TestingFallback\n  prompt #\"\n    Generate comprehensive unit tests for this Python function using {{ framework }}.\n\n    Function to test:\n    ```python\n    {{ function_code }}\n    ```\n\n    Function signature: {{ function_signature }}\n    Docstring: {{ docstring }}\n\n    Please generate specific, executable test cases that cover:\n    1. Normal valid inputs with expected outputs\n    2. Edge cases (empty inputs, boundary values, etc.)\n    3. Error conditions with appropriate exception testing\n    4. Different input types and combinations\n\n    Make the tests specific and executable, not just templates. Include actual test data and assertions.\n    Use proper {{ framework }} syntax and assertions.\n\n    Generate 3-5 comprehensive test cases that would provide good coverage.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Generate coverage improvement suggestions\nfunction GenerateCoverageImprovements(\n  file_path: string,\n  uncovered_functions: string[],\n  missing_lines: int[],\n  current_coverage: float\n) -> CoverageImprovement[] {\n  client TestingFallback\n  prompt #\"\n    Analyze this Python file's coverage and suggest specific improvements:\n\n    File: {{ file_path }}\n    Current coverage: {{ current_coverage }}%\n    Uncovered functions: {{ uncovered_functions }}\n    Missing lines: {{ missing_lines }}\n\n    Generate specific, actionable suggestions for improving test coverage.\n    Focus on the most critical gaps and provide concrete test recommendations.\n\n    For each suggestion, include:\n    - Which function or area needs testing\n    - What type of tests are missing\n    - Priority level\n    - Specific test scenarios to implement\n    - Code examples where helpful\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Generate mutation testing strategy for a Python file\nfunction GenerateMutationStrategy(\n  file_path: string,\n  function_code: string,\n  existing_tests: string,\n  target_functions: string[]\n) -> MutationStrategy {\n  client TestingFallback\n  prompt #\"\n    Analyze this Python code and generate an intelligent mutation testing strategy:\n\n    File: {{ file_path }}\n    Target functions: {{ target_functions }}\n\n    Code to analyze:\n    ```python\n    {{ function_code }}\n    ```\n\n    Existing tests:\n    ```python\n    {{ existing_tests }}\n    ```\n\n    Generate a comprehensive mutation testing strategy that includes:\n    1. Recommended mutation operators based on the code patterns\n    2. Priority areas where mutations are most likely to reveal test weaknesses\n    3. Expected number of mutants to generate\n    4. Rationale for the mutation strategy\n\n    Focus on mutations that are most likely to:\n    - Reveal missing test cases\n    - Expose weak assertions\n    - Find boundary condition issues\n    - Identify logical errors in tests\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Analyze mutation testing results and provide insights\nfunction AnalyzeMutationResults(\n  file_path: string,\n  mutation_results: string,\n  survived_mutants: string[],\n  killed_mutants: string[],\n  mutation_score: float\n) -> MutationReport {\n  client TestingFallback\n  prompt #\"\n    Analyze these mutation testing results and provide comprehensive insights:\n\n    File: {{ file_path }}\n    Mutation Score: {{ mutation_score }}%\n\n    Mutation Results Summary:\n    {{ mutation_results }}\n\n    Survived Mutants (these reveal test weaknesses):\n    {{ survived_mutants }}\n\n    Killed Mutants (these show good test coverage):\n    {{ killed_mutants }}\n\n    Provide a detailed analysis including:\n    1. Overall assessment of test quality based on mutation score\n    2. Identification of weak areas where mutants survived\n    3. Specific suggestions for improving tests to kill surviving mutants\n    4. Function-by-function mutation score analysis\n    5. Prioritized recommendations for test improvements\n\n    Focus on actionable insights that will help improve test effectiveness.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Generate specific test improvements based on surviving mutants\nfunction GenerateTestImprovements(\n  function_code: string,\n  surviving_mutants: string[],\n  current_tests: string\n) -> string[] {\n  client TestingFallback\n  prompt #\"\n    Analyze these surviving mutants and generate specific test improvements:\n\n    Original function:\n    ```python\n    {{ function_code }}\n    ```\n\n    Current tests:\n    ```python\n    {{ current_tests }}\n    ```\n\n    Surviving mutants that need to be killed:\n    {{ surviving_mutants }}\n\n    For each surviving mutant, provide:\n    1. Why the current tests failed to catch this mutation\n    2. Specific test cases that would kill this mutant\n    3. The exact test code to add\n    4. Explanation of what the new test validates\n\n    Generate concrete, executable test code that will improve mutation score.\n\n    Return an array of test improvement suggestions as strings.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Test the fuzzing function\ntest sample_fuzzing {\n  functions [GenerateFuzzingInputs]\n  args {\n    function_signature \"add_numbers(a, b)\"\n    function_code #\"\n      def add_numbers(a, b):\n          \"\"\"Add two numbers together.\"\"\"\n          return a + b\n    \"#\n    num_inputs 5\n  }\n}\n\n// Test the unit test generation\ntest sample_unit_tests {\n  functions [GenerateUnitTestCases]\n  args {\n    function_signature \"divide_numbers(x, y)\"\n    function_code #\"\n      def divide_numbers(x, y):\n          \"\"\"Divide x by y.\"\"\"\n          return x / y\n    \"#\n    framework \"pytest\"\n    docstring \"Divide x by y.\"\n  }\n}\n\n// Test the mutation strategy generation\ntest sample_mutation_strategy {\n  functions [GenerateMutationStrategy]\n  args {\n    file_path \"test_calculator.py\"\n    function_code #\"\n      def add_numbers(a, b):\n          \"\"\"Add two numbers together.\"\"\"\n          if a < 0 or b < 0:\n              return 0\n          return a + b\n      \n      def multiply(x, y):\n          \"\"\"Multiply two numbers.\"\"\"\n          result = 0\n          for i in range(y):\n              result += x\n          return result\n    \"#\n    existing_tests #\"\n      def test_add_positive():\n          assert add_numbers(2, 3) == 5\n      \n      def test_multiply_basic():\n          assert multiply(3, 4) == 12\n    \"#\n    target_functions [\"add_numbers\", \"multiply\"]\n  }\n}",
}

def get_baml_files():
    return _file_map