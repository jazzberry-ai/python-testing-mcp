# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "main.baml": "// baml_src/main.baml\n\n// Define the structure for a single test case.\nclass TestCase {\n  name string @description(\"The name of the test function, e.g., 'test_addition'\")\n  body string @description(\"The complete Python code for the test function body, correctly indented.\")\n}\n\n// Define the overall structure for the generated Python test file.\nclass PythonTestFile {\n  imports string[] @description(\"A list of necessary import statements for the test file.\")\n  test_cases TestCase[] @description(\"An array of test cases to be included in the file.\")\n}\n\n// Define the Gemini client\nclient<llm> Gemini {\n  provider google-ai\n  options {\n    model \"gemini-2.5-flash\"\n    api_key env.GEMINI_API_KEY\n  }\n}\n\n// Define the structure for fuzzing inputs.\nclass FuzzInput {\n  value string @description(\"A single fuzzing input, represented as a string.\")\n}\n\n// Define the function that will call the LLM using Gemini.\nfunction GenerateTests(source_code: string) -> PythonTestFile {\n  client Gemini\n\n  prompt #\"\n    You are an expert Python software tester. Your task is to generate a comprehensive suite of unittest tests for the following Python code.\n\n    Do not add any commentary before or after the response.\n\n    Source Code:\n    ---\n    {{ source_code }}\n    ---\n\n    Generate 4-6 different test cases covering:\n    1. Normal/positive cases\n    2. Edge cases (zero, empty, boundary values)\n    3. Different data types if the function supports them\n    4. Error cases that should raise exceptions (use self.assertRaises for these)\n\n    For each test case, provide:\n    - A descriptive test name that starts with 'test_'\n    - The complete function body with proper assertions\n    - For error cases, use self.assertRaises(ExceptionType): followed by the function call\n\n    Please generate the tests in the required format.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Define the function that will call the LLM for fuzzing.\nfunction GenerateFuzzInputs(source_code: string) -> FuzzInput[] {\n  client Gemini\n\n  prompt #\"\n    You are a software security and testing expert.\n    Your task is to generate a Python list of 20 diverse and challenging inputs for fuzz testing the following Python function.\n    The list should include edge cases, malformed data, large inputs, and any other inputs that might cause unexpected behavior or crashes.\n    \n    IMPORTANT: Each input must be a simple Python literal (numbers, strings, lists, tuples, booleans, None) that can be parsed by ast.literal_eval(). \n    Do NOT use expressions like 10**100, float('inf'), or function calls. Use actual literal values like:\n    - Large integers: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n    - For infinity-like behavior, use very large numbers\n    - For NaN-like behavior, use None or unusual combinations\n    - Use actual byte strings like b'abc', not b'abc'\n\n    Here is the function to fuzz:\n    ```python\n    {{ source_code }}\n    ```\n\n    Please generate the fuzzing inputs in the required format.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Define the structure for coverage analysis data.\nclass CoverageAnalysis {\n  function_name string @description(\"The name of the function being analyzed\")\n  branches string[] @description(\"List of conditional branches found in the function\")\n  loops string[] @description(\"List of loops found in the function\")\n  exception_paths string[] @description(\"List of exception handling paths\")\n  return_statements string[] @description(\"List of different return paths\")\n  parameters string[] @description(\"Function parameters and their types if available\")\n}\n\n// Define the function for coverage-focused test generation.\nfunction GenerateCoverageTests(source_code: string, analysis: CoverageAnalysis) -> PythonTestFile {\n  client Gemini\n\n  prompt #\"\n    You are an expert Python test engineer specializing in achieving maximum code coverage. Your task is to generate a comprehensive test suite that achieves 100% line and branch coverage for the following Python function.\n\n    Do not add any commentary before or after the response.\n\n    Source Code:\n    ---\n    {{ source_code }}\n    ---\n\n    Coverage Analysis:\n    - Function: {{ analysis.function_name }}\n    - Conditional branches: {{ analysis.branches }}\n    - Loops: {{ analysis.loops }}\n    - Exception paths: {{ analysis.exception_paths }}\n    - Return statements: {{ analysis.return_statements }}\n    - Parameters: {{ analysis.parameters }}\n\n    Generate test cases that cover ALL of the following:\n\n    1. **Branch Coverage**: Create test cases for EVERY conditional branch (if/elif/else)\n       - Test both True and False conditions for each if statement\n       - Test all elif branches individually\n       - Test else branches when conditions are False\n\n    2. **Loop Coverage**: \n       - Test loops with zero iterations (empty collections, False conditions)\n       - Test loops with one iteration\n       - Test loops with multiple iterations\n       - Test early loop exits (break statements)\n       - Test continue statements in loops\n\n    3. **Exception Coverage**:\n       - Test all try/except blocks by triggering each exception type\n       - Test finally blocks execution\n       - Test successful execution without exceptions\n\n    4. **Return Path Coverage**:\n       - Test each different return statement in the function\n       - Test functions that return None implicitly\n       - Test early returns from conditional blocks\n\n    5. **Parameter Coverage**:\n       - Test with different parameter types and values\n       - Test boundary values for numeric parameters\n       - Test empty/null values for collection parameters\n       - Test invalid parameter types that might cause exceptions\n\n    6. **Edge Cases**:\n       - Test with minimum and maximum values\n       - Test with empty inputs ([], \"\", {}, None)\n       - Test with single-element collections\n       - Test with very large inputs\n\n    For each test case:\n    - Use descriptive names that indicate what coverage they achieve (e.g., 'test_branch_condition_true', 'test_loop_zero_iterations')\n    - Include comments explaining which coverage path is being tested\n    - Use appropriate assertions to verify correct behavior\n    - Use self.assertRaises() for exception testing\n    - Ensure proper test isolation (each test is independent)\n\n    Generate enough test cases to achieve 100% coverage of all identified paths.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Define the structure for mutation analysis results.\nclass MutationAnalysis {\n  critical_survivors string[] @description(\"List of critical mutations that survived testing\")\n  edge_case_gaps string[] @description(\"Edge cases revealed by mutation testing\")\n  test_recommendations string[] @description(\"Specific test cases recommended to catch survivors\")\n  overall_assessment string @description(\"Overall assessment of test suite quality\")\n}\n\n// Define the function for analyzing mutation testing results.\nfunction AnalyzeMutationResults(source_code: string, survived_mutations: string, mutation_details: string) -> MutationAnalysis {\n  client Gemini\n\n  prompt #\"\n    You are an expert in mutation testing and test quality analysis. Your task is to analyze the results of mutation testing and provide actionable insights to improve test coverage.\n\n    Do not add any commentary before or after the response.\n\n    ORIGINAL SOURCE CODE:\n    ---\n    {{ source_code }}\n    ---\n\n    SURVIVED MUTATIONS (mutations that tests failed to catch):\n    ---\n    {{ survived_mutations }}\n    ---\n\n    DETAILED MUTATION INFORMATION:\n    ---\n    {{ mutation_details }}\n    ---\n\n    Analyze these results and provide:\n\n    1. **Critical Survivors**: Identify mutations that represent serious potential bugs\n       - Focus on logic errors, boundary conditions, error handling gaps\n       - Explain why each is dangerous in production\n\n    2. **Edge Case Gaps**: Identify missing edge case coverage revealed by mutations\n       - Boundary value testing gaps\n       - Error condition testing gaps\n       - Special input handling gaps\n\n    3. **Test Recommendations**: For each important survived mutation, suggest specific test cases\n       - Provide concrete test scenarios with example inputs\n       - Focus on tests that would catch the most dangerous mutations\n       - Be specific about assertions and expected behaviors\n\n    4. **Overall Assessment**: Summarize the test suite quality\n       - Mutation testing score interpretation\n       - Most critical areas needing attention\n       - Priority order for improvements\n\n    Focus on actionable, specific recommendations that will most effectively improve test quality.\n\n    {{ ctx.output_format }}\n  \"#\n}",
}

def get_baml_files():
    return _file_map